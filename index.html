<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Application Designer</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
        color: white;
        overflow: hidden;
      }

      .container {
        display: flex;
        height: 100vh;
      }

      .toolbar {
        width: 250px;
        background: rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(10px);
        padding: 20px;
        box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
      }

      .toolbar h2 {
        margin: 0 0 20px 0;
        font-size: 18px;
        color: #ffffff;
        text-align: center;
        border-bottom: 2px solid rgba(255, 255, 255, 0.3);
        padding-bottom: 10px;
      }

      .mode-section {
        margin-bottom: 30px;
      }

      .mode-section h3 {
        margin: 0 0 10px 0;
        font-size: 14px;
        color: #b8c6db;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .mode-buttons {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .mode-btn {
        padding: 10px 15px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        background: rgba(255, 255, 255, 0.1);
        color: white;
        cursor: pointer;
        border-radius: 8px;
        transition: all 0.3s ease;
        text-align: center;
        font-size: 13px;
      }

      .mode-btn:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-2px);
      }

      .mode-btn.active {
        background: rgba(255, 255, 255, 0.3);
        border-color: #ffffff;
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
      }

      .element-buttons {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .element-btn {
        padding: 12px 15px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        background: rgba(255, 255, 255, 0.1);
        color: white;
        cursor: pointer;
        border-radius: 8px;
        transition: all 0.3s ease;
        text-align: left;
        font-size: 13px;
      }

      .element-btn:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateX(5px);
      }

      .element-btn.active {
        background: rgba(255, 255, 255, 0.3);
        border-color: #ffffff;
      }

      .canvas-container {
        flex: 1;
        position: relative;
        overflow: hidden;
      }

      .canvas {
        width: 100%;
        height: 100%;
        cursor: crosshair;
        background: radial-gradient(
            circle at 25% 25%,
            rgba(255, 255, 255, 0.1) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 75% 75%,
            rgba(255, 255, 255, 0.05) 0%,
            transparent 50%
          );
        position: relative;
      }

      .canvas.move-mode {
        cursor: move;
      }

      .canvas.connection-mode {
        cursor: crosshair;
      }

      .canvas.edit-mode {
        cursor: pointer;
      }

      .element {
        position: absolute;
        cursor: pointer;
        user-select: none;
        transition: all 0.2s ease;
        border: 2px solid rgba(255, 255, 255, 0.6);
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(5px);
        color: white;
        font-size: 12px;
        font-weight: 500;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      }

      .element:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: scale(1.05);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
      }

      .element.selected {
        border-color: #ffeb3b;
        background: rgba(255, 235, 59, 0.2);
        box-shadow: 0 0 20px rgba(255, 235, 59, 0.5);
      }

      .element.connection-source {
        border-color: #4caf50;
        background: rgba(76, 175, 80, 0.2);
        box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
      }

      .element.dragging {
        opacity: 0.8;
        transform: scale(1.1);
        z-index: 1000;
      }

      .element.has-parent {
        border-color: rgba(255, 152, 0, 0.8);
        background: rgba(255, 152, 0, 0.1);
      }

      .collection {
        border-radius: 8px;
        min-width: 120px;
        min-height: 80px;
      }

      .function {
        border-radius: 50px;
        min-width: 100px;
        min-height: 60px;
      }

      .object {
        clip-path: polygon(
          50% 0%,
          100% 25%,
          100% 75%,
          50% 100%,
          0% 75%,
          0% 25%
        );
        min-width: 100px;
        min-height: 80px;
      }

      .input-output {
        border-radius: 20px;
        min-width: 80px;
        min-height: 40px;
        font-size: 10px;
        background: rgba(76, 175, 80, 0.2);
        border-color: rgba(76, 175, 80, 0.8);
      }

      .connection-line {
        position: absolute;
        pointer-events: none;
        z-index: 1;
        stroke: rgba(255, 255, 255, 0.8);
        stroke-width: 2;
        fill: none;
        filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.3));
      }

      .connection-arrow {
        fill: rgba(255, 255, 255, 0.8);
        stroke: rgba(255, 255, 255, 0.8);
        stroke-width: 1;
      }

      .status {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        padding: 8px 12px;
        border-radius: 5px;
        font-size: 12px;
        color: white;
      }

      .context-menu {
        position: absolute;
        background: rgba(30, 30, 30, 0.95);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        padding: 5px 0;
        min-width: 150px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        z-index: 10000;
        display: none;
      }

      .context-menu-item {
        padding: 8px 15px;
        cursor: pointer;
        font-size: 12px;
        color: white;
        transition: background 0.2s ease;
      }

      .context-menu-item:hover {
        background: rgba(255, 255, 255, 0.1);
      }

      .context-menu-separator {
        height: 1px;
        background: rgba(255, 255, 255, 0.2);
        margin: 5px 0;
      }

      .controls {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        gap: 10px;
      }

      .control-btn {
        padding: 8px 12px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.3);
        color: white;
        border-radius: 5px;
        cursor: pointer;
        font-size: 12px;
        transition: all 0.2s ease;
      }

      .control-btn:hover {
        background: rgba(255, 255, 255, 0.2);
      }

      .edit-overlay {
        position: absolute;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        padding: 15px;
        min-width: 250px;
        z-index: 10000;
        display: none;
      }

      .edit-field {
        margin-bottom: 10px;
      }

      .edit-field label {
        display: block;
        margin-bottom: 5px;
        font-size: 12px;
        color: #b8c6db;
      }

      .edit-field input,
      .edit-field textarea {
        width: 100%;
        padding: 8px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 4px;
        background: rgba(255, 255, 255, 0.1);
        color: white;
        font-size: 12px;
      }

      .edit-field input:focus,
      .edit-field textarea:focus {
        outline: none;
        border-color: #ffeb3b;
      }

      .edit-buttons {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
      }

      .edit-btn {
        padding: 6px 12px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 4px;
        background: rgba(255, 255, 255, 0.1);
        color: white;
        cursor: pointer;
        font-size: 12px;
        transition: all 0.2s ease;
      }

      .edit-btn:hover {
        background: rgba(255, 255, 255, 0.2);
      }

      .edit-btn.primary {
        background: rgba(76, 175, 80, 0.3);
        border-color: rgba(76, 175, 80, 0.8);
      }

      .edit-btn.primary:hover {
        background: rgba(76, 175, 80, 0.5);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="toolbar">
        <h2>Application Designer</h2>

        <div class="mode-section">
          <h3>Interaction Mode</h3>
          <div class="mode-buttons">
            <div class="mode-btn active" data-mode="create">Create / Child</div>
            <div class="mode-btn" data-mode="connection">Connection</div>
            <div class="mode-btn" data-mode="move">Movement</div>
            <div class="mode-btn" data-mode="edit">Edit</div>
          </div>
        </div>

        <div class="mode-section">
          <h3>Element Types</h3>
          <div class="element-buttons">
            <div class="element-btn active" data-type="collection">
              [Collections] - Rectangles
            </div>
            <div class="element-btn" data-type="function">
              (Functions) - Ovals
            </div>
            <div class="element-btn" data-type="object">
              {Objects} - Polygons
            </div>
            <div class="element-btn" data-type="input-output">
              &gt;Inputs/Outputs&lt;
            </div>
          </div>
        </div>

        <div class="mode-section">
          <h3>Actions</h3>
          <div class="mode-buttons">
            <div class="mode-btn" onclick="saveProject()">Save Project</div>
            <div class="mode-btn" onclick="loadProject()">Load Project</div>
            <div class="mode-btn" onclick="clearCanvas()">Clear Canvas</div>
          </div>
        </div>
      </div>

      <div class="canvas-container">
        <div class="controls">
          <div class="control-btn" onclick="zoomIn()">Zoom In</div>
          <div class="control-btn" onclick="zoomOut()">Zoom Out</div>
          <div class="control-btn" onclick="resetView()">Reset View</div>
        </div>

        <div class="canvas" id="canvas"></div>
        <div class="status" id="status">Ready - Create/Child Mode</div>
      </div>
    </div>

    <div class="context-menu" id="contextMenu">
      <div class="context-menu-item" onclick="editElement()">Edit</div>
      <div class="context-menu-item" onclick="duplicateElement()">
        Duplicate
      </div>
      <div class="context-menu-separator"></div>
      <div class="context-menu-item" onclick="deleteElement()">Delete</div>
    </div>

    <div class="edit-overlay" id="editOverlay">
      <div class="edit-field">
        <label>Text:</label>
        <input type="text" id="editText" />
      </div>
      <div class="edit-field">
        <label>Width:</label>
        <input type="number" id="editWidth" />
      </div>
      <div class="edit-field">
        <label>Height:</label>
        <input type="number" id="editHeight" />
      </div>
      <div class="edit-field">
        <label>X Position:</label>
        <input type="number" id="editX" />
      </div>
      <div class="edit-field">
        <label>Y Position:</label>
        <input type="number" id="editY" />
      </div>
      <div class="edit-buttons">
        <div class="edit-btn" onclick="cancelEdit()">Cancel</div>
        <div class="edit-btn primary" onclick="saveEdit()">Save</div>
      </div>
    </div>

    <script>
      // Core data models
      class Element {
        constructor(type, x, y, text = "", parent = null) {
          this.id = Date.now() + Math.random();
          this.type = type;
          this.x = x;
          this.y = y;
          this.text = text || this.getDefaultText();
          this.width = this.getDefaultWidth();
          this.height = this.getDefaultHeight();
          this.parent = parent;
          this.children = [];
          this.connections = [];

          // Add to parent's children if parent exists
          if (parent) {
            parent.children.push(this);

            // For input-output elements, position relative to parent
            if (type === "input-output") {
              this.x = parent.x + parent.width + 20;
              this.y = parent.y + (parent.children.length - 1) * 50;
            }
          }
        }

        getDefaultText() {
          const defaults = {
            collection: "Collection",
            function: "Function",
            object: "Object",
            "input-output": "I/O",
          };
          return defaults[this.type] || "Element";
        }

        getDefaultWidth() {
          const defaults = {
            collection: 120,
            function: 100,
            object: 100,
            "input-output": 80,
          };
          return defaults[this.type] || 100;
        }

        getDefaultHeight() {
          const defaults = {
            collection: 80,
            function: 60,
            object: 80,
            "input-output": 40,
          };
          return defaults[this.type] || 60;
        }

        serialize() {
          return {
            id: this.id,
            type: this.type,
            x: this.x,
            y: this.y,
            text: this.text,
            width: this.width,
            height: this.height,
            parent: this.parent ? this.parent.id : null,
            children: this.children.map((child) => child.id),
            connections: this.connections.map((conn) => conn.id),
          };
        }
      }

      class Connection {
        constructor(from, to) {
          this.id = Date.now() + Math.random();
          this.from = from;
          this.to = to;

          // Add connection to both elements
          from.connections.push(this);
          to.connections.push(this);
        }

        serialize() {
          return {
            id: this.id,
            from: this.from.id,
            to: this.to.id,
          };
        }
      }

      // Application state
      let currentMode = "create";
      let currentElementType = "collection";
      let elements = [];
      let connections = [];
      let selectedElement = null;
      let dragging = false;
      let dragOffset = { x: 0, y: 0 };
      let connectionStart = null;
      let zoom = 1;
      let pan = { x: 0, y: 0 };
      let contextMenuTarget = null;
      let editingElement = null;

      // DOM elements
      const canvas = document.getElementById("canvas");
      const status = document.getElementById("status");
      const contextMenu = document.getElementById("contextMenu");
      const editOverlay = document.getElementById("editOverlay");

      // Event listeners
      document.addEventListener("DOMContentLoaded", initializeApp);
      canvas.addEventListener("click", handleCanvasClick);
      canvas.addEventListener("mousedown", handleMouseDown);
      canvas.addEventListener("mousemove", handleMouseMove);
      canvas.addEventListener("mouseup", handleMouseUp);
      canvas.addEventListener("contextmenu", handleContextMenu);
      document.addEventListener("click", hideContextMenu);

      // Mode switching
      document.querySelectorAll(".mode-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          document
            .querySelectorAll(".mode-btn")
            .forEach((b) => b.classList.remove("active"));
          btn.classList.add("active");
          currentMode = btn.dataset.mode;
          updateCanvasCursor();
          updateStatus();

          // Reset connection state when switching modes
          if (currentMode !== "connection") {
            resetConnectionState();
          }
        });
      });

      // Element type switching
      document.querySelectorAll(".element-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          document
            .querySelectorAll(".element-btn")
            .forEach((b) => b.classList.remove("active"));
          btn.classList.add("active");
          currentElementType = btn.dataset.type;
          updateStatus();
        });
      });

      function initializeApp() {
        updateCanvasCursor();
        updateStatus();
        render();
      }

      function updateCanvasCursor() {
        canvas.className = `canvas ${currentMode}-mode`;
      }

      function updateStatus() {
        const modeText = {
          create: "Create/Child Mode",
          connection: "Connection Mode",
          move: "Movement Mode",
          edit: "Edit Mode",
        };
        const elementText = {
          collection: "Collections",
          function: "Functions",
          object: "Objects",
          "input-output": "Inputs/Outputs",
        };

        let statusText = `${modeText[currentMode]} - ${elementText[currentElementType]}`;

        if (currentMode === "connection" && connectionStart) {
          statusText += " - Select target element";
        }

        status.textContent = statusText;
      }

      function handleCanvasClick(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        if (currentMode === "create") {
          const clickedElement = getElementAt(x, y);
          if (clickedElement) {
            if (e.shiftKey) {
              // Delete element
              deleteElementById(clickedElement.id);
            } else {
              // Create child element
              createChildElement(clickedElement, x, y);
            }
          } else {
            // Create new root element
            createElementAt(x, y);
          }
        } else if (currentMode === "connection") {
          const clickedElement = getElementAt(x, y);
          if (clickedElement) {
            if (!connectionStart) {
              connectionStart = clickedElement;
              selectElement(clickedElement);
              clickedElement.domElement.classList.add("connection-source");
              updateStatus();
            } else if (clickedElement !== connectionStart) {
              createConnection(connectionStart, clickedElement);
              resetConnectionState();
            }
          } else {
            resetConnectionState();
          }
        } else if (currentMode === "edit") {
          const clickedElement = getElementAt(x, y);
          if (clickedElement) {
            selectElement(clickedElement);
            openEditOverlay(clickedElement);
          }
        }
      }

      function handleMouseDown(e) {
        if (currentMode === "move") {
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          const element = getElementAt(x, y);
          if (element) {
            dragging = true;
            selectElement(element);
            dragOffset.x = x - element.x;
            dragOffset.y = y - element.y;
            element.domElement.classList.add("dragging");
          }
        }
      }

      function handleMouseMove(e) {
        if (dragging && selectedElement && currentMode === "move") {
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          selectedElement.x = x - dragOffset.x;
          selectedElement.y = y - dragOffset.y;

          updateElementPosition(selectedElement);
          updateConnections();
        }
      }

      function handleMouseUp() {
        if (dragging && selectedElement) {
          dragging = false;
          selectedElement.domElement.classList.remove("dragging");
        }
      }

      function handleContextMenu(e) {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const element = getElementAt(x, y);
        if (element) {
          contextMenuTarget = element;
          contextMenu.style.left = e.clientX + "px";
          contextMenu.style.top = e.clientY + "px";
          contextMenu.style.display = "block";
        }
      }

      function hideContextMenu() {
        contextMenu.style.display = "none";
        contextMenuTarget = null;
      }

      function resetConnectionState() {
        if (connectionStart) {
          connectionStart.domElement.classList.remove("connection-source");
          connectionStart = null;
        }
        updateStatus();
      }

      function createElementAt(x, y, parent = null) {
        const element = new Element(currentElementType, x, y, "", parent);
        elements.push(element);
        createElementDOM(element);
        selectElement(element);
        render();
        return element;
      }

      function createChildElement(parent, x, y) {
        let childX = x;
        let childY = y;

        // For input-output elements, position them relative to parent
        if (currentElementType === "input-output") {
          childX = parent.x + parent.width + 20;
          childY = parent.y + parent.children.length * 50;
        }

        const child = createElementAt(childX, childY, parent);
        return child;
      }

      function createElementDOM(element) {
        const div = document.createElement("div");
        div.className = `element ${element.type}`;
        if (element.parent) {
          div.classList.add("has-parent");
        }

        div.style.left = element.x + "px";
        div.style.top = element.y + "px";
        div.style.width = element.width + "px";
        div.style.height = element.height + "px";
        div.textContent = element.text;
        div.dataset.id = element.id;

        // Make text editable on double-click
        div.addEventListener("dblclick", (e) => {
          e.stopPropagation();
          editElementText(element);
        });

        canvas.appendChild(div);
        element.domElement = div;
      }

      function editElementText(element) {
        const newText = prompt("Edit element text:", element.text);
        if (newText !== null) {
          element.text = newText;
          element.domElement.textContent = newText;
        }
      }

      function updateElementPosition(element) {
        if (element.domElement) {
          element.domElement.style.left = element.x + "px";
          element.domElement.style.top = element.y + "px";
        }
      }

      function getElementAt(x, y) {
        return elements.find((element) => {
          return (
            x >= element.x &&
            x <= element.x + element.width &&
            y >= element.y &&
            y <= element.y + element.height
          );
        });
      }

      function selectElement(element) {
        if (selectedElement && selectedElement.domElement) {
          selectedElement.domElement.classList.remove("selected");
        }
        selectedElement = element;
        if (element && element.domElement) {
          element.domElement.classList.add("selected");
        }
      }

      function deleteElementById(id) {
        const element = elements.find((e) => e.id === id);
        if (!element) return;

        // Remove from parent's children
        if (element.parent) {
          element.parent.children = element.parent.children.filter(
            (child) => child.id !== id
          );
        }

        // Remove children
        element.children.forEach((child) => {
          deleteElementById(child.id);
        });

        // Remove connections
        connections = connections.filter(
          (conn) => conn.from.id !== id && conn.to.id !== id
        );

        // Remove from elements array
        const index = elements.findIndex((e) => e.id === id);
        if (index !== -1) {
          if (element.domElement) {
            element.domElement.remove();
          }
          elements.splice(index, 1);
        }

        if (selectedElement && selectedElement.id === id) {
          selectedElement = null;
        }

        render();
      }

      function createConnection(from, to) {
        // Check if connection already exists
        const existingConnection = connections.find(
          (conn) =>
            (conn.from.id === from.id && conn.to.id === to.id) ||
            (conn.from.id === to.id && conn.to.id === from.id)
        );

        if (existingConnection) {
          return;
        }

        const connection = new Connection(from, to);
        connections.push(connection);
        updateConnections();
      }

      function updateConnections() {
        // Remove existing connection SVGs
        document
          .querySelectorAll(".connection-svg")
          .forEach((svg) => svg.remove());

        // Create new connection SVGs
        connections.forEach((connection) => {
          createConnectionDOM(connection);
        });
      }

      function createConnectionDOM(connection) {
        const svg = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "svg"
        );
        svg.className = "connection-svg";
        svg.style.position = "absolute";
        svg.style.pointerEvents = "none";
        svg.style.zIndex = "1";
        svg.style.overflow = "visible";

        const fromX = connection.from.x + connection.from.width / 2;
        const fromY = connection.from.y + connection.from.height / 2;
        const toX = connection.to.x + connection.to.width / 2;
        const toY = connection.to.y + connection.to.height / 2;

        const minX = Math.min(fromX, toX) - 20;
        const minY = Math.min(fromY, toY) - 20;
        const maxX = Math.max(fromX, toX) + 20;
        const maxY = Math.max(fromY, toY) + 20;

        svg.style.left = minX + "px";
        svg.style.top = minY + "px";
        svg.style.width = maxX - minX + "px";
        svg.style.height = maxY - minY + "px";

        // Create line
        const line = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "line"
        );
        line.className = "connection-line";
        line.setAttribute("x1", fromX - minX);
        line.setAttribute("y1", fromY - minY);
        line.setAttribute("x2", toX - minX);
        line.setAttribute("y2", toY - minY);
        line.setAttribute("stroke", "rgba(255, 255, 255, 0.8)");
        line.setAttribute("stroke-width", "2");

        svg.appendChild(line);
        canvas.appendChild(svg);
      }

      function render() {
        updateConnections();
      }

      // Context menu functions
      function editElement() {
        if (contextMenuTarget) {
          editElementText(contextMenuTarget);
        }
        hideContextMenu();
      }

      function duplicateElement() {
        if (contextMenuTarget) {
          const newElement = new Element(
            contextMenuTarget.type,
            contextMenuTarget.x + 20,
            contextMenuTarget.y + 20,
            contextMenuTarget.text
          );
          elements.push(newElement);
          createElementDOM(newElement);
          selectElement(newElement);
          render();
        }
        hideContextMenu();
      }

      function deleteElement() {
        if (contextMenuTarget) {
          deleteElementById(contextMenuTarget.id);
        }
        hideContextMenu();
      }

      // Project management
      function saveProject() {
        const project = {
          elements: elements.map((e) => e.serialize()),
          connections: connections.map((c) => c.serialize()),
        };
        const data = JSON.stringify(project, null, 2);
        const blob = new Blob([data], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "application_design.json";
        a.click();
        URL.revokeObjectURL(url);
      }

      function loadProject() {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".json";
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                const project = JSON.parse(e.target.result);
                clearCanvas();

                // Restore elements
                project.elements.forEach((elementData) => {
                  const element = new Element(
                    elementData.type,
                    elementData.x,
                    elementData.y,
                    elementData.text
                  );
                  element.id = elementData.id;
                  element.width = elementData.width;
                  element.height = elementData.height;
                  elements.push(element);
                  createElementDOM(element);
                });

                // Restore connections
                project.connections.forEach((connData) => {
                  const from = elements.find((e) => e.id === connData.from);
                  const to = elements.find((e) => e.id === connData.to);
                  if (from && to) {
                    const connection = new Connection(from, to);
                    connection.id = connData.id;
                    connections.push(connection);
                  }
                });

                render();
              } catch (error) {
                alert("Error loading project: " + error.message);
              }
            };
            reader.readAsText(file);
          }
        };
        input.click();
      }

      function clearCanvas() {
        elements.forEach((element) => {
          if (element.domElement) {
            element.domElement.remove();
          }
        });
        elements = [];
        connections = [];
        selectedElement = null;
        document
          .querySelectorAll(".connection")
          .forEach((conn) => conn.remove());
      }

      // View controls
      function zoomIn() {
        zoom *= 1.2;
        canvas.style.transform = `scale(${zoom}) translate(${pan.x}px, ${pan.y}px)`;
      }

      function zoomOut() {
        zoom /= 1.2;
        canvas.style.transform = `scale(${zoom}) translate(${pan.x}px, ${pan.y}px)`;
      }

      function resetView() {
        zoom = 1;
        pan = { x: 0, y: 0 };
        canvas.style.transform = "scale(1) translate(0px, 0px)";
      }
    </script>
  </body>
</html>
